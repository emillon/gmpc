/* advanced_settings.c generated by valac 0.12.0, the Vala compiler
 * generated from advanced_settings.vala, do not modify */

/* Gnome Music Player Client (GMPC)
 * Copyright (C) 2011-2011 Qball Cow <qball@gmpclient.org>
 * Project homepage: http://gmpclient.org/
 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gtktransition.h>
#include <stdlib.h>
#include <string.h>
#include <config.h>
#include "gmpc-extras.h"
#include <glib/gi18n-lib.h>
#include <pango/pango.h>
#include <plugin.h>
#include <config1.h>
#include <tray-icon2.h>
#include <plugin-internal.h>
#include <main.h>
#include <preferences.h>

#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _Block4Data Block4Data;

struct _Block4Data {
	int _ref_count_;
	const gmpcPluginParent* p;
};



#define use_transition_as TRUE
#define some_unique_name_as VERSION
static void _lambda19_ (GtkToggleButton* source);
static void __lambda19__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
static void _lambda20_ (GtkToggleButton* source);
static void __lambda20__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
static void _lambda21_ (GtkToggleButton* source);
static void __lambda21__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
static void _lambda22_ (GtkToggleButton* source);
static void __lambda22__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
static Block4Data* block4_data_ref (Block4Data* _data4_);
static void block4_data_unref (Block4Data* _data4_);
static void _lambda23_ (GtkToggleButton* source, Block4Data* _data4_);
static void __lambda23__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);


/**
 * Show a dialog with some advanced interface settings 
 */
static void _lambda19_ (GtkToggleButton* source) {
	gboolean _tmp0_;
	g_return_if_fail (source != NULL);
	_tmp0_ = gtk_toggle_button_get_active (source);
	cfg_set_single_value_as_int (config, "Interface", "hide-album-art", (gint) _tmp0_);
}


static void __lambda19__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	_lambda19_ (_sender);
}


static void _lambda20_ (GtkToggleButton* source) {
	gboolean _tmp0_;
	g_return_if_fail (source != NULL);
	_tmp0_ = gtk_toggle_button_get_active (source);
	cfg_set_single_value_as_int (config, "Interface", "hide-favorites-icon", (gint) _tmp0_);
}


static void __lambda20__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	_lambda20_ (_sender);
}


static void _lambda21_ (GtkToggleButton* source) {
	gboolean _tmp0_;
	g_return_if_fail (source != NULL);
	_tmp0_ = gtk_toggle_button_get_active (source);
	cfg_set_single_value_as_int (config, "Now Playing", "use-backdrop", (gint) _tmp0_);
}


static void __lambda21__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	_lambda21_ (_sender);
}


static void _lambda22_ (GtkToggleButton* source) {
	g_return_if_fail (source != NULL);
	trayicon2_toggle_use_appindicator ();
}


static void __lambda22__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	_lambda22_ (_sender);
}


static Block4Data* block4_data_ref (Block4Data* _data4_) {
	g_atomic_int_inc (&_data4_->_ref_count_);
	return _data4_;
}


static void block4_data_unref (Block4Data* _data4_) {
	if (g_atomic_int_dec_and_test (&_data4_->_ref_count_)) {
		g_slice_free (Block4Data, _data4_);
	}
}


static void _lambda23_ (GtkToggleButton* source, Block4Data* _data4_) {
	gboolean _tmp0_;
	g_return_if_fail (source != NULL);
	_tmp0_ = gtk_toggle_button_get_active (source);
	gmpc_plugin_set_enabled (_data4_->p, (gint) _tmp0_);
	pl3_update_go_menu ();
	preferences_window_update ();
}


static void __lambda23__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	_lambda23_ (_sender, self);
}


void advanced_settings (void) {
	const gchar* _tmp0_ = NULL;
	GtkDialog* _tmp1_ = NULL;
	GtkDialog* win;
	GmpcWidgetsQtable* _tmp2_ = NULL;
	GmpcWidgetsQtable* vbox;
	const gchar* _tmp3_ = NULL;
	GtkLabel* _tmp4_ = NULL;
	GtkLabel* label;
	const gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_;
	GtkCheckButton* _tmp8_ = NULL;
	GtkCheckButton* ck;
	gint _tmp9_;
	GtkCheckButton* _tmp10_ = NULL;
	gint _tmp11_;
	GtkCheckButton* _tmp12_ = NULL;
	gint _tmp13_;
	gboolean _tmp14_;
	const gchar* _tmp17_ = NULL;
	GtkLabel* _tmp18_ = NULL;
	const gchar* _tmp19_ = NULL;
	gchar* _tmp20_ = NULL;
	gchar* _tmp21_;
	_tmp0_ = _ ("Advanced settings");
	_tmp1_ = (GtkDialog*) gtk_dialog_new_with_buttons (_tmp0_, NULL, 0, "gtk-close", GTK_RESPONSE_CLOSE, NULL);
	win = g_object_ref_sink (_tmp1_);
	_tmp2_ = gmpc_widgets_qtable_new ();
	vbox = g_object_ref_sink (_tmp2_);
	gtk_widget_set_size_request ((GtkWidget*) win, 450, -1);
	gmpc_widgets_qtable_set_header_height (vbox, 32);
	gtk_container_add ((GtkContainer*) win->vbox, (GtkWidget*) vbox);
	gtk_container_set_border_width ((GtkContainer*) vbox, (guint) 8);
	_tmp3_ = _ ("Interface");
	_tmp4_ = (GtkLabel*) gtk_label_new (_tmp3_);
	label = g_object_ref_sink (_tmp4_);
	gtk_label_set_ellipsize (label, PANGO_ELLIPSIZE_END);
	_tmp5_ = _ ("Interface");
	_tmp6_ = g_markup_printf_escaped ("<b>%s</b>", _tmp5_);
	_tmp7_ = _tmp6_;
	gtk_label_set_markup (label, _tmp7_);
	_g_free0 (_tmp7_);
	gtk_misc_set_alignment ((GtkMisc*) label, 0.0f, 0.5f);
	gmpc_widgets_qtable_add_header (vbox, (GtkWidget*) label);
	_tmp8_ = (GtkCheckButton*) gtk_check_button_new_with_label ("Hide album art");
	ck = g_object_ref_sink (_tmp8_);
	_tmp9_ = cfg_get_single_value_as_int_with_default (config, "Interface", "hide-album-art", 0);
	gtk_toggle_button_set_active ((GtkToggleButton*) ck, (gboolean) _tmp9_);
	g_signal_connect ((GtkToggleButton*) ck, "toggled", (GCallback) __lambda19__gtk_toggle_button_toggled, NULL);
	gtk_container_add ((GtkContainer*) vbox, (GtkWidget*) ck);
	_tmp10_ = (GtkCheckButton*) gtk_check_button_new_with_label ("Hide favorite icon");
	_g_object_unref0 (ck);
	ck = g_object_ref_sink (_tmp10_);
	_tmp11_ = cfg_get_single_value_as_int_with_default (config, "Interface", "hide-favorites-icon", 0);
	gtk_toggle_button_set_active ((GtkToggleButton*) ck, (gboolean) _tmp11_);
	g_signal_connect ((GtkToggleButton*) ck, "toggled", (GCallback) __lambda20__gtk_toggle_button_toggled, NULL);
	gtk_container_add ((GtkContainer*) vbox, (GtkWidget*) ck);
	_tmp12_ = (GtkCheckButton*) gtk_check_button_new_with_label ("Use backdrops (restart required)");
	_g_object_unref0 (ck);
	ck = g_object_ref_sink (_tmp12_);
	_tmp13_ = cfg_get_single_value_as_int_with_default (config, "Now Playing", "use-backdrop", 0);
	gtk_toggle_button_set_active ((GtkToggleButton*) ck, (gboolean) _tmp13_);
	g_signal_connect ((GtkToggleButton*) ck, "toggled", (GCallback) __lambda21__gtk_toggle_button_toggled, NULL);
	gtk_container_add ((GtkContainer*) vbox, (GtkWidget*) ck);
	_tmp14_ = trayicon2_have_appindicator_support ();
	if (_tmp14_) {
		GtkCheckButton* _tmp15_ = NULL;
		gint _tmp16_;
		_tmp15_ = (GtkCheckButton*) gtk_check_button_new_with_label ("Use legacy tray icon");
		_g_object_unref0 (ck);
		ck = g_object_ref_sink (_tmp15_);
		_tmp16_ = cfg_get_single_value_as_int_with_default (config, "tray-icon2", "use_appindicator", 1);
		gtk_toggle_button_set_active ((GtkToggleButton*) ck, !((gboolean) _tmp16_));
		g_signal_connect ((GtkToggleButton*) ck, "toggled", (GCallback) __lambda22__gtk_toggle_button_toggled, NULL);
		gtk_container_add ((GtkContainer*) vbox, (GtkWidget*) ck);
	}
	_tmp17_ = _ ("Browsers");
	_tmp18_ = (GtkLabel*) gtk_label_new (_tmp17_);
	_g_object_unref0 (label);
	label = g_object_ref_sink (_tmp18_);
	gtk_label_set_ellipsize (label, PANGO_ELLIPSIZE_END);
	_tmp19_ = _ ("Browsers");
	_tmp20_ = g_markup_printf_escaped ("<b>%s</b>", _tmp19_);
	_tmp21_ = _tmp20_;
	gtk_label_set_markup (label, _tmp21_);
	_g_free0 (_tmp21_);
	gtk_misc_set_alignment ((GtkMisc*) label, 0.0f, 0.5f);
	gmpc_widgets_qtable_add_header (vbox, (GtkWidget*) label);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp22_;
			_tmp22_ = TRUE;
			while (TRUE) {
				Block4Data* _data4_;
				gboolean _tmp23_ = FALSE;
				gboolean _tmp24_;
				_data4_ = g_slice_new0 (Block4Data);
				_data4_->_ref_count_ = 1;
				if (!_tmp22_) {
					i++;
				}
				_tmp22_ = FALSE;
				if (!(i < num_plugins)) {
					block4_data_unref (_data4_);
					_data4_ = NULL;
					break;
				}
				_data4_->p = plugins[i];
				_tmp24_ = gmpc_plugin_is_browser (_data4_->p);
				if (_tmp24_) {
					gboolean _tmp25_;
					_tmp25_ = gmpc_plugin_has_enabled (_data4_->p);
					_tmp23_ = _tmp25_;
				} else {
					_tmp23_ = FALSE;
				}
				if (_tmp23_) {
					const gchar* _tmp26_ = NULL;
					GtkCheckButton* _tmp27_ = NULL;
					gint _tmp28_;
					_tmp26_ = gmpc_plugin_get_name (_data4_->p);
					_tmp27_ = (GtkCheckButton*) gtk_check_button_new_with_label (_tmp26_);
					_g_object_unref0 (ck);
					ck = g_object_ref_sink (_tmp27_);
					_tmp28_ = gmpc_plugin_get_enabled (_data4_->p);
					gtk_toggle_button_set_active ((GtkToggleButton*) ck, (gboolean) _tmp28_);
					g_signal_connect_data ((GtkToggleButton*) ck, "toggled", (GCallback) __lambda23__gtk_toggle_button_toggled, block4_data_ref (_data4_), (GClosureNotify) block4_data_unref, 0);
					gtk_container_add ((GtkContainer*) vbox, (GtkWidget*) ck);
				}
				block4_data_unref (_data4_);
				_data4_ = NULL;
			}
		}
	}
	gtk_widget_show_all ((GtkWidget*) win);
	gtk_dialog_run (win);
	gtk_object_destroy ((GtkObject*) win);
	_g_object_unref0 (ck);
	_g_object_unref0 (label);
	_g_object_unref0 (vbox);
	_g_object_unref0 (win);
	return;
}



