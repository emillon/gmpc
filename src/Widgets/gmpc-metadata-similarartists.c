/* gmpc-metadata-similarartists.c generated by valac 0.12.0, the Vala compiler
 * generated from gmpc-metadata-similarartists.vala, do not modify */

/* Gnome Music Player Client (GMPC)
 * Copyright (C) 2004-2011 Qball Cow <qball@gmpclient.org>
 * Project homepage: http://gmpclient.org/
 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gtktransition.h>
#include <stdlib.h>
#include <string.h>
#include <config.h>
#include "gmpc-extras.h"
#include <libmpd/libmpdclient.h>
#include <libmpd/libmpd.h>
#include <misc.h>
#include <gdk/gdk.h>
#include <gmpc-meta-watcher.h>
#include <metadata.h>
#include <glib/gi18n-lib.h>
#include <plugin.h>
#include <libmpd/libmpd-internal.h>
#include <gmpc-metaimage.h>
#include <pango/pango.h>
#include <main.h>

#define _mpd_freeSong0(var) ((var == NULL) ? NULL : (var = (mpd_freeSong (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _mpd_data_free0(var) ((var == NULL) ? NULL : (var = (mpd_data_free (var), NULL)))
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))
#define _meta_data_free0(var) ((var == NULL) ? NULL : (var = (meta_data_free (var), NULL)))

struct _GmpcMetaDataWidgetsSimilarArtistsPrivate {
	mpd_Song* song;
	gint columns;
	gint button_width;
};


static gpointer gmpc_meta_data_widgets_similar_artists_parent_class = NULL;

#define use_transition_mdsa TRUE
#define some_unique_name_mdsa VERSION
#define GMPC_META_DATA_WIDGETS_SIMILAR_ARTISTS_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GMPC_META_DATA_WIDGETS_TYPE_SIMILAR_ARTISTS, GmpcMetaDataWidgetsSimilarArtistsPrivate))
enum  {
	GMPC_META_DATA_WIDGETS_SIMILAR_ARTISTS_DUMMY_PROPERTY
};
static void gmpc_meta_data_widgets_similar_artists_size_changed (GmpcMetaDataWidgetsSimilarArtists* self, GdkRectangle* alloc);
static void gmpc_meta_data_widgets_similar_artists_metadata_changed (GmpcMetaDataWidgetsSimilarArtists* self, GmpcMetaWatcher* gmw2, const mpd_Song* song, MetaDataType type, MetaDataResult _result_, const MetaData* met);
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
static void gmpc_meta_data_widgets_similar_artists_artist_button_clicked (GmpcMetaDataWidgetsSimilarArtists* self, GtkButton* button);
static gboolean _misc_header_expose_event_gtk_widget_expose_event (GtkWidget* _sender, GdkEventExpose* event, gpointer self);
static void _gmpc_meta_data_widgets_similar_artists_artist_button_clicked_gtk_button_clicked (GtkButton* _sender, gpointer self);
#define np2_LOG_DOMAIN "NowPlaying"
static void _gmpc_meta_data_widgets_similar_artists_metadata_changed_gmpc_meta_watcher_data_changed (GmpcMetaWatcher* _sender, const mpd_Song* song, MetaDataType type, MetaDataResult _result_, const MetaData* met, gpointer self);
static void _gmpc_meta_data_widgets_similar_artists_size_changed_gtk_widget_size_allocate (GtkWidget* _sender, GdkRectangle* allocation, gpointer self);
static void gmpc_meta_data_widgets_similar_artists_finalize (GObject* obj);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void gmpc_meta_data_widgets_similar_artists_size_changed (GmpcMetaDataWidgetsSimilarArtists* self, GdkRectangle* alloc) {
	gint t_column;
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	t_column = (*alloc).width / self->priv->button_width;
	if (t_column < 1) {
		_tmp0_ = 1;
	} else {
		_tmp0_ = t_column;
	}
	t_column = _tmp0_;
	if (t_column != self->priv->columns) {
		GList* _tmp1_ = NULL;
		GList* list;
		gint i;
		guint _tmp3_;
		_tmp1_ = gtk_container_get_children ((GtkContainer*) self);
		list = _tmp1_;
		{
			GList* child_collection;
			GList* child_it;
			child_collection = list;
			for (child_it = child_collection; child_it != NULL; child_it = child_it->next) {
				GtkWidget* _tmp2_;
				GtkWidget* child;
				_tmp2_ = _g_object_ref0 ((GtkWidget*) child_it->data);
				child = _tmp2_;
				{
					g_object_ref ((GObject*) child);
					gtk_container_remove ((GtkContainer*) self, child);
					_g_object_unref0 (child);
				}
			}
		}
		self->priv->columns = t_column;
		i = 0;
		_tmp3_ = g_list_length (list);
		gtk_table_resize ((GtkTable*) self, (_tmp3_ / self->priv->columns) + 1, (guint) self->priv->columns);
		{
			GList* item_collection;
			GList* item_it;
			item_collection = list;
			for (item_it = item_collection; item_it != NULL; item_it = item_it->next) {
				GtkWidget* _tmp4_;
				GtkWidget* item;
				_tmp4_ = _g_object_ref0 ((GtkWidget*) item_it->data);
				item = _tmp4_;
				{
					gtk_table_attach ((GtkTable*) self, item, (guint) (i % self->priv->columns), (guint) ((i % self->priv->columns) + 1), (guint) (i / self->priv->columns), (guint) ((i / self->priv->columns) + 1), GTK_EXPAND | GTK_FILL, GTK_SHRINK, (guint) 0, (guint) 0);
					i++;
					_g_object_unref0 (item);
				}
			}
		}
		gtk_widget_show_all ((GtkWidget*) self);
		_g_list_free0 (list);
	}
}


/**
     * Handle signals from the metadata object.
     */
static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


static void gmpc_meta_data_widgets_similar_artists_metadata_changed (GmpcMetaDataWidgetsSimilarArtists* self, GmpcMetaWatcher* gmw2, const mpd_Song* song, MetaDataType type, MetaDataResult _result_, const MetaData* met) {
	gint _tmp0_;
	GList* _tmp1_ = NULL;
	GList* child_list;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (gmw2 != NULL);
	g_return_if_fail (song != NULL);
	if (type != META_ARTIST_SIMILAR) {
		return;
	}
	_tmp0_ = g_utf8_collate (self->priv->song->artist, song->artist);
	if (_tmp0_ != 0) {
		return;
	}
	_tmp1_ = gtk_container_get_children ((GtkContainer*) self);
	child_list = _tmp1_;
	{
		GList* child_collection;
		GList* child_it;
		child_collection = child_list;
		for (child_it = child_collection; child_it != NULL; child_it = child_it->next) {
			GtkWidget* _tmp2_;
			GtkWidget* child;
			_tmp2_ = _g_object_ref0 ((GtkWidget*) child_it->data);
			child = _tmp2_;
			{
				gtk_object_destroy ((GtkObject*) child);
				_g_object_unref0 (child);
			}
		}
	}
	if (_result_ == META_DATA_UNAVAILABLE) {
		_tmp4_ = TRUE;
	} else {
		gboolean _tmp5_;
		_tmp5_ = meta_data_is_empty (met);
		_tmp4_ = _tmp5_;
	}
	if (_tmp4_) {
		_tmp3_ = TRUE;
	} else {
		gboolean _tmp6_;
		_tmp6_ = meta_data_is_text_list (met);
		_tmp3_ = !_tmp6_;
	}
	if (_tmp3_) {
		const gchar* _tmp7_ = NULL;
		GtkLabel* _tmp8_ = NULL;
		GtkLabel* label;
		_tmp7_ = _ ("Unavailable");
		_tmp8_ = (GtkLabel*) gtk_label_new (_tmp7_);
		label = g_object_ref_sink (_tmp8_);
		gtk_table_attach ((GtkTable*) self, (GtkWidget*) label, (guint) 0, (guint) 1, (guint) 0, (guint) 1, GTK_SHRINK, GTK_SHRINK, (guint) 0, (guint) 0);
		_g_object_unref0 (label);
	} else {
		if (_result_ == META_DATA_FETCHING) {
			const gchar* _tmp9_ = NULL;
			GtkLabel* _tmp10_ = NULL;
			GtkLabel* label;
			_tmp9_ = _ ("Fetching");
			_tmp10_ = (GtkLabel*) gtk_label_new (_tmp9_);
			label = g_object_ref_sink (_tmp10_);
			gtk_table_attach ((GtkTable*) self, (GtkWidget*) label, (guint) 0, (guint) 1, (guint) 0, (guint) 1, GTK_SHRINK, GTK_SHRINK, (guint) 0, (guint) 0);
			_g_object_unref0 (label);
		} else {
			GList* in_db_list;
			GList* _tmp11_ = NULL;
			GList* _tmp12_ = NULL;
			GList* list;
			gint items;
			gint i;
			guint _tmp34_;
			guint llength;
			gint _tmp35_ = 0;
			in_db_list = NULL;
			_tmp11_ = meta_data_get_text_list (met);
			_tmp12_ = g_list_copy (_tmp11_);
			list = _tmp12_;
			list = g_list_sort (list, (GCompareFunc) g_utf8_collate);
			items = 30;
			i = 0;
			if (list != NULL) {
				GList* liter;
				MpdData* _tmp13_ = NULL;
				MpdData* data;
				gint q;
				GList* _tmp30_ = NULL;
				liter = NULL;
				mpd_database_search_field_start (connection, MPD_TAG_ITEM_ARTIST);
				_tmp13_ = mpd_database_search_commit (connection);
				data = _tmp13_;
				q = 0;
				if (data != NULL) {
					MpdData* _tmp14_ = NULL;
					MpdData* iter;
					GList* _tmp15_ = NULL;
					gchar* _tmp16_;
					gchar* artist;
					gboolean _tmp17_;
					data = misc_sort_mpddata_by_album_disc_track (data);
					_tmp14_ = mpd_data_get_first (data);
					iter = _tmp14_;
					_tmp15_ = g_list_first (list);
					liter = _tmp15_;
					_tmp16_ = g_strdup ("");
					artist = _tmp16_;
					_tmp17_ = g_utf8_validate (iter->tag, (gssize) (-1), NULL);
					if (_tmp17_ == FALSE) {
						g_error ("gmpc-metadata-similarartists.vala:120: Failed to validate");
					}
					if (iter->tag != NULL) {
						gchar* _tmp18_ = NULL;
						_tmp18_ = g_utf8_casefold (iter->tag, (gssize) (-1));
						_g_free0 (artist);
						artist = _tmp18_;
					}
					{
						gboolean _tmp19_;
						_tmp19_ = TRUE;
						while (TRUE) {
							gchar* _tmp22_ = NULL;
							gchar* _tmp23_;
							gint _tmp24_;
							gint _tmp25_;
							gint res;
							if (!_tmp19_) {
								gboolean _tmp20_ = FALSE;
								gboolean _tmp21_ = FALSE;
								if (iter != NULL) {
									_tmp21_ = liter != NULL;
								} else {
									_tmp21_ = FALSE;
								}
								if (_tmp21_) {
									_tmp20_ = i < items;
								} else {
									_tmp20_ = FALSE;
								}
								if (!_tmp20_) {
									break;
								}
							}
							_tmp19_ = FALSE;
							_tmp22_ = g_utf8_casefold ((const gchar*) liter->data, (gssize) (-1));
							_tmp23_ = _tmp22_;
							_tmp24_ = g_utf8_collate (_tmp23_, artist);
							_tmp25_ = _tmp24_;
							_g_free0 (_tmp23_);
							res = _tmp25_;
							q++;
							if (res == 0) {
								GtkWidget* _tmp26_ = NULL;
								gchar* _tmp27_;
								gchar* d;
								_tmp26_ = gmpc_meta_data_widgets_similar_artists_new_artist_button (self, iter->tag, TRUE);
								in_db_list = g_list_prepend (in_db_list, _tmp26_);
								i++;
								_tmp27_ = g_strdup ((const gchar*) liter->data);
								d = _tmp27_;
								liter = liter->next;
								list = g_list_remove (list, d);
								iter = mpd_data_get_next_real (iter, FALSE);
								if (iter != NULL) {
									gchar* _tmp28_ = NULL;
									_tmp28_ = g_utf8_casefold (iter->tag, (gssize) (-1));
									_g_free0 (artist);
									artist = _tmp28_;
								}
								_g_free0 (d);
							} else {
								if (res > 0) {
									iter = mpd_data_get_next_real (iter, FALSE);
									if (iter != NULL) {
										gchar* _tmp29_ = NULL;
										_tmp29_ = g_utf8_casefold (iter->tag, (gssize) (-1));
										_g_free0 (artist);
										artist = _tmp29_;
									}
								} else {
									liter = liter->next;
								}
							}
						}
					}
					_g_free0 (artist);
				}
				_tmp30_ = g_list_first (list);
				liter = _tmp30_;
				while (TRUE) {
					gboolean _tmp31_ = FALSE;
					gchar* _tmp32_;
					gchar* artist;
					GtkWidget* _tmp33_ = NULL;
					if (liter != NULL) {
						_tmp31_ = i < items;
					} else {
						_tmp31_ = FALSE;
					}
					if (!_tmp31_) {
						break;
					}
					_tmp32_ = g_strdup ((const gchar*) liter->data);
					artist = _tmp32_;
					_tmp33_ = gmpc_meta_data_widgets_similar_artists_new_artist_button (self, artist, FALSE);
					in_db_list = g_list_prepend (in_db_list, _tmp33_);
					i++;
					liter = liter->next;
					_g_free0 (artist);
				}
				_mpd_data_free0 (data);
			}
			in_db_list = g_list_reverse (in_db_list);
			i = 0;
			gtk_widget_hide ((GtkWidget*) self);
			_tmp34_ = g_list_length (in_db_list);
			llength = _tmp34_;
			self->priv->columns = ((GtkWidget*) self)->allocation.width / self->priv->button_width;
			if (self->priv->columns < 1) {
				_tmp35_ = 1;
			} else {
				_tmp35_ = self->priv->columns;
			}
			self->priv->columns = _tmp35_;
			gtk_table_resize ((GtkTable*) self, (llength / self->priv->columns) + 1, (guint) self->priv->columns);
			{
				GList* item_collection;
				GList* item_it;
				item_collection = in_db_list;
				for (item_it = item_collection; item_it != NULL; item_it = item_it->next) {
					GtkWidget* _tmp36_;
					GtkWidget* item;
					_tmp36_ = _g_object_ref0 ((GtkWidget*) item_it->data);
					item = _tmp36_;
					{
						gtk_table_attach ((GtkTable*) self, item, (guint) (i % self->priv->columns), (guint) ((i % self->priv->columns) + 1), (guint) (i / self->priv->columns), (guint) ((i / self->priv->columns) + 1), GTK_EXPAND | GTK_FILL, GTK_SHRINK, (guint) 0, (guint) 0);
						i++;
						_g_object_unref0 (item);
					}
				}
			}
			_g_list_free0 (list);
			__g_list_free__g_object_unref0_0 (in_db_list);
		}
	}
	gtk_widget_show_all ((GtkWidget*) self);
	_g_list_free0 (child_list);
}


static void gmpc_meta_data_widgets_similar_artists_artist_button_clicked (GmpcMetaDataWidgetsSimilarArtists* self, GtkButton* button) {
	gconstpointer _tmp0_ = NULL;
	const gchar* artist;
	g_return_if_fail (self != NULL);
	g_return_if_fail (button != NULL);
	_tmp0_ = g_object_get_data ((GObject*) button, "artist");
	artist = (const gchar*) ((const gchar*) _tmp0_);
	info2_fill_artist_view (artist);
}


static gboolean _misc_header_expose_event_gtk_widget_expose_event (GtkWidget* _sender, GdkEventExpose* event, gpointer self) {
	gboolean result;
	result = misc_header_expose_event (_sender, event);
	return result;
}


static void _gmpc_meta_data_widgets_similar_artists_artist_button_clicked_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	gmpc_meta_data_widgets_similar_artists_artist_button_clicked (self, _sender);
}


GtkWidget* gmpc_meta_data_widgets_similar_artists_new_artist_button (GmpcMetaDataWidgetsSimilarArtists* self, const gchar* artist, gboolean in_db) {
	GtkWidget* result = NULL;
	GtkHBox* _tmp0_ = NULL;
	GtkHBox* hbox;
	GtkEventBox* _tmp1_ = NULL;
	GtkEventBox* event;
	GmpcMetaImage* _tmp2_ = NULL;
	GmpcMetaImage* image;
	mpd_Song* _tmp3_ = NULL;
	mpd_Song* song;
	gchar* _tmp4_;
	GtkLabel* _tmp5_ = NULL;
	GtkLabel* label;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (artist != NULL, NULL);
	_tmp0_ = (GtkHBox*) gtk_hbox_new (FALSE, 6);
	hbox = g_object_ref_sink (_tmp0_);
	gtk_container_set_border_width ((GtkContainer*) hbox, (guint) 4);
	_tmp1_ = (GtkEventBox*) gtk_event_box_new ();
	event = g_object_ref_sink (_tmp1_);
	gtk_widget_set_app_paintable ((GtkWidget*) event, TRUE);
	gtk_event_box_set_visible_window (event, TRUE);
	g_signal_connect ((GtkWidget*) event, "expose-event", (GCallback) _misc_header_expose_event_gtk_widget_expose_event, NULL);
	gtk_widget_set_size_request ((GtkWidget*) event, self->priv->button_width - 20, 60);
	_tmp2_ = gmpc_metaimage_new_size (META_ARTIST_ART, 48);
	image = g_object_ref_sink (_tmp2_);
	gmpc_metaimage_set_no_cover_icon (image, "no-artist");
	gmpc_metaimage_set_loading_cover_icon (image, "fetching-artist");
	_tmp3_ = mpd_newSong ();
	song = _tmp3_;
	_tmp4_ = g_strdup (artist);
	_g_free0 (song->artist);
	song->artist = _tmp4_;
	gmpc_metaimage_set_squared (image, TRUE);
	gmpc_metaimage_update_cover_from_song_delayed (image, song);
	gtk_box_pack_start ((GtkBox*) hbox, (GtkWidget*) image, FALSE, FALSE, (guint) 0);
	_tmp5_ = (GtkLabel*) gtk_label_new (artist);
	label = g_object_ref_sink (_tmp5_);
	gtk_widget_set_tooltip_text ((GtkWidget*) label, artist);
	gtk_label_set_selectable (label, TRUE);
	gtk_misc_set_alignment ((GtkMisc*) label, 0.0f, 0.5f);
	gtk_label_set_ellipsize (label, PANGO_ELLIPSIZE_END);
	gtk_box_pack_start ((GtkBox*) hbox, (GtkWidget*) label, TRUE, TRUE, (guint) 0);
	if (in_db) {
		GtkButton* _tmp6_ = NULL;
		GtkButton* find;
		GtkImage* _tmp7_ = NULL;
		GtkImage* _tmp8_;
		gchar* _tmp9_ = NULL;
		_tmp6_ = (GtkButton*) gtk_button_new ();
		find = g_object_ref_sink (_tmp6_);
		_tmp7_ = (GtkImage*) gtk_image_new_from_stock ("gtk-find", GTK_ICON_SIZE_MENU);
		_tmp8_ = g_object_ref_sink (_tmp7_);
		gtk_container_add ((GtkContainer*) find, (GtkWidget*) _tmp8_);
		_g_object_unref0 (_tmp8_);
		gtk_button_set_relief (find, GTK_RELIEF_NONE);
		gtk_box_pack_start ((GtkBox*) hbox, (GtkWidget*) find, FALSE, FALSE, (guint) 0);
		_tmp9_ = g_strdup_printf ("%s", artist);
		g_object_set_data_full ((GObject*) find, "artist", (void*) _tmp9_, (GDestroyNotify) g_free);
		g_signal_connect_object (find, "clicked", (GCallback) _gmpc_meta_data_widgets_similar_artists_artist_button_clicked_gtk_button_clicked, self, 0);
		_g_object_unref0 (find);
	}
	gtk_container_add ((GtkContainer*) event, (GtkWidget*) hbox);
	result = (GtkWidget*) event;
	_g_object_unref0 (label);
	_mpd_freeSong0 (song);
	_g_object_unref0 (image);
	_g_object_unref0 (hbox);
	return result;
}


static void _gmpc_meta_data_widgets_similar_artists_metadata_changed_gmpc_meta_watcher_data_changed (GmpcMetaWatcher* _sender, const mpd_Song* song, MetaDataType type, MetaDataResult _result_, const MetaData* met, gpointer self) {
	gmpc_meta_data_widgets_similar_artists_metadata_changed (self, _sender, song, type, _result_, met);
}


static void _gmpc_meta_data_widgets_similar_artists_size_changed_gtk_widget_size_allocate (GtkWidget* _sender, GdkRectangle* allocation, gpointer self) {
	gmpc_meta_data_widgets_similar_artists_size_changed (self, allocation);
}


void gmpc_meta_data_widgets_similar_artists_first_show (GmpcMetaDataWidgetsSimilarArtists* self) {
	g_return_if_fail (self != NULL);
	g_log (np2_LOG_DOMAIN, G_LOG_LEVEL_DEBUG, "gmpc-metadata-similarartists.vala:238: First Show()");
	if (!self->first_show_b) {
		MetaData* item;
		MetaData* _tmp0_ = NULL;
		MetaDataResult _tmp1_;
		MetaDataResult gm_result;
		item = NULL;
		g_signal_connect_object (gmw, "data-changed", (GCallback) _gmpc_meta_data_widgets_similar_artists_metadata_changed_gmpc_meta_watcher_data_changed, self, 0);
		g_signal_connect_object ((GtkWidget*) self, "size-allocate", (GCallback) _gmpc_meta_data_widgets_similar_artists_size_changed_gtk_widget_size_allocate, self, 0);
		_tmp1_ = gmpc_meta_watcher_get_meta_path (gmw, self->priv->song, META_ARTIST_SIMILAR, &_tmp0_);
		_meta_data_free0 (item);
		item = _tmp0_;
		gm_result = _tmp1_;
		if (gm_result == META_DATA_AVAILABLE) {
			gmpc_meta_data_widgets_similar_artists_metadata_changed (self, gmw, self->priv->song, META_ARTIST_SIMILAR, gm_result, item);
		}
		self->first_show_b = TRUE;
		_meta_data_free0 (item);
	}
}


static gpointer _mpd_songDup0 (gpointer self) {
	return self ? mpd_songDup (self) : NULL;
}


GmpcMetaDataWidgetsSimilarArtists* gmpc_meta_data_widgets_similar_artists_construct (GType object_type, MpdObj* server, const mpd_Song* song) {
	GmpcMetaDataWidgetsSimilarArtists * self = NULL;
	mpd_Song* _tmp0_;
	g_return_val_if_fail (server != NULL, NULL);
	g_return_val_if_fail (song != NULL, NULL);
	self = (GmpcMetaDataWidgetsSimilarArtists*) g_object_new (object_type, NULL);
	_tmp0_ = _mpd_songDup0 (song);
	_mpd_freeSong0 (self->priv->song);
	self->priv->song = _tmp0_;
	gtk_table_set_homogeneous ((GtkTable*) self, TRUE);
	gtk_table_set_row_spacings ((GtkTable*) self, (guint) 6);
	gtk_table_set_col_spacings ((GtkTable*) self, (guint) 6);
	gtk_widget_show ((GtkWidget*) self);
	return self;
}


GmpcMetaDataWidgetsSimilarArtists* gmpc_meta_data_widgets_similar_artists_new (MpdObj* server, const mpd_Song* song) {
	return gmpc_meta_data_widgets_similar_artists_construct (GMPC_META_DATA_WIDGETS_TYPE_SIMILAR_ARTISTS, server, song);
}


static void gmpc_meta_data_widgets_similar_artists_class_init (GmpcMetaDataWidgetsSimilarArtistsClass * klass) {
	gmpc_meta_data_widgets_similar_artists_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GmpcMetaDataWidgetsSimilarArtistsPrivate));
	G_OBJECT_CLASS (klass)->finalize = gmpc_meta_data_widgets_similar_artists_finalize;
}


static void gmpc_meta_data_widgets_similar_artists_instance_init (GmpcMetaDataWidgetsSimilarArtists * self) {
	self->priv = GMPC_META_DATA_WIDGETS_SIMILAR_ARTISTS_GET_PRIVATE (self);
	self->priv->song = NULL;
	self->priv->columns = 1;
	self->priv->button_width = 200;
	self->first_show_b = FALSE;
}


static void gmpc_meta_data_widgets_similar_artists_finalize (GObject* obj) {
	GmpcMetaDataWidgetsSimilarArtists * self;
	self = GMPC_META_DATA_WIDGETS_SIMILAR_ARTISTS (obj);
	_mpd_freeSong0 (self->priv->song);
	G_OBJECT_CLASS (gmpc_meta_data_widgets_similar_artists_parent_class)->finalize (obj);
}


GType gmpc_meta_data_widgets_similar_artists_get_type (void) {
	static volatile gsize gmpc_meta_data_widgets_similar_artists_type_id__volatile = 0;
	if (g_once_init_enter (&gmpc_meta_data_widgets_similar_artists_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GmpcMetaDataWidgetsSimilarArtistsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gmpc_meta_data_widgets_similar_artists_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GmpcMetaDataWidgetsSimilarArtists), 0, (GInstanceInitFunc) gmpc_meta_data_widgets_similar_artists_instance_init, NULL };
		GType gmpc_meta_data_widgets_similar_artists_type_id;
		gmpc_meta_data_widgets_similar_artists_type_id = g_type_register_static (GTK_TYPE_TABLE, "GmpcMetaDataWidgetsSimilarArtists", &g_define_type_info, 0);
		g_once_init_leave (&gmpc_meta_data_widgets_similar_artists_type_id__volatile, gmpc_meta_data_widgets_similar_artists_type_id);
	}
	return gmpc_meta_data_widgets_similar_artists_type_id__volatile;
}



