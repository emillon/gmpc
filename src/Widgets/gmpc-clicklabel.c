/* gmpc-clicklabel.c generated by valac 0.12.0, the Vala compiler
 * generated from gmpc-clicklabel.vala, do not modify */

/* Gnome Music Player Client (GMPC)
 * Copyright (C) 2004-2011 Qball Cow <qball@gmpclient.org>
 * Project homepage: http://gmpclient.org/
 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/

#include <glib.h>
#include <glib-object.h>
#include "gmpc-extras.h"
#include <gtk/gtk.h>
#include <pango/pango.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <gdk/gdk.h>


#define GMPC_CLICKLABEL_TYPE_SIGHANDLER (gmpc_clicklabel_sighandler_get_type ())
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _pango_attr_list_unref0(var) ((var == NULL) ? NULL : (var = (pango_attr_list_unref (var), NULL)))
#define _pango_font_description_free0(var) ((var == NULL) ? NULL : (var = (pango_font_description_free (var), NULL)))
#define _pango_attribute_destroy0(var) ((var == NULL) ? NULL : (var = (pango_attribute_destroy (var), NULL)))

struct _GmpcClicklabelPrivate {
	GtkLabel* label;
	gboolean sensitive;
	gint size;
	gboolean italic;
	gboolean bold;
	gboolean underline;
	PangoAttrList* attributes;
	gboolean mouseCursorInside;
	gulong handlers[6];
};

typedef enum  {
	GMPC_CLICKLABEL_SIGHANDLER_ENTER_NOTIFY,
	GMPC_CLICKLABEL_SIGHANDLER_LEAVE_NOTIFY,
	GMPC_CLICKLABEL_SIGHANDLER_BUTTON_RELEASE,
	GMPC_CLICKLABEL_SIGHANDLER_KEY_RELEASE,
	GMPC_CLICKLABEL_SIGHANDLER_FOCUS_IN,
	GMPC_CLICKLABEL_SIGHANDLER_FOCUS_OUT,
	GMPC_CLICKLABEL_SIGHANDLER_NUM_SIGNALS
} GmpcClicklabelSighandler;


static gpointer gmpc_clicklabel_parent_class = NULL;

#define GMPC_CLICKLABEL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GMPC_TYPE_CLICKLABEL, GmpcClicklabelPrivate))
enum  {
	GMPC_CLICKLABEL_DUMMY_PROPERTY
};
static GType gmpc_clicklabel_sighandler_get_type (void) G_GNUC_UNUSED;
static void gmpc_clicklabel_update (GmpcClicklabel* self);
static gboolean _lambda3_ (GtkWidget* source, GdkEventCrossing* event, GmpcClicklabel* self);
static gboolean __lambda3__gtk_widget_enter_notify_event (GtkWidget* _sender, GdkEventCrossing* event, gpointer self);
static gboolean _lambda4_ (GtkWidget* source, GdkEventCrossing* event, GmpcClicklabel* self);
static gboolean __lambda4__gtk_widget_leave_notify_event (GtkWidget* _sender, GdkEventCrossing* event, gpointer self);
static gboolean _lambda5_ (GtkWidget* source, GdkEventCrossing* event, GmpcClicklabel* self);
static gboolean __lambda5__gtk_widget_enter_notify_event (GtkWidget* _sender, GdkEventCrossing* event, gpointer self);
static gboolean _lambda6_ (GtkWidget* source, GdkEventCrossing* event, GmpcClicklabel* self);
static gboolean __lambda6__gtk_widget_leave_notify_event (GtkWidget* _sender, GdkEventCrossing* event, gpointer self);
static gboolean _lambda7_ (GtkWidget* source, GdkEventButton* event, GmpcClicklabel* self);
static gboolean __lambda7__gtk_widget_button_release_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
static gboolean _lambda8_ (GtkWidget* source, GdkEventKey* event, GmpcClicklabel* self);
static gboolean __lambda8__gtk_widget_key_release_event (GtkWidget* _sender, GdkEventKey* event, gpointer self);
static gboolean _lambda9_ (GtkWidget* source, GdkEventFocus* event, GmpcClicklabel* self);
static gboolean __lambda9__gtk_widget_focus_in_event (GtkWidget* _sender, GdkEventFocus* event, gpointer self);
static gboolean _lambda10_ (GtkWidget* source, GdkEventFocus* event, GmpcClicklabel* self);
static gboolean __lambda10__gtk_widget_focus_out_event (GtkWidget* _sender, GdkEventFocus* event, gpointer self);
static void gmpc_clicklabel_finalize (GObject* obj);


static GType gmpc_clicklabel_sighandler_get_type (void) {
	static volatile gsize gmpc_clicklabel_sighandler_type_id__volatile = 0;
	if (g_once_init_enter (&gmpc_clicklabel_sighandler_type_id__volatile)) {
		static const GEnumValue values[] = {{GMPC_CLICKLABEL_SIGHANDLER_ENTER_NOTIFY, "GMPC_CLICKLABEL_SIGHANDLER_ENTER_NOTIFY", "enter-notify"}, {GMPC_CLICKLABEL_SIGHANDLER_LEAVE_NOTIFY, "GMPC_CLICKLABEL_SIGHANDLER_LEAVE_NOTIFY", "leave-notify"}, {GMPC_CLICKLABEL_SIGHANDLER_BUTTON_RELEASE, "GMPC_CLICKLABEL_SIGHANDLER_BUTTON_RELEASE", "button-release"}, {GMPC_CLICKLABEL_SIGHANDLER_KEY_RELEASE, "GMPC_CLICKLABEL_SIGHANDLER_KEY_RELEASE", "key-release"}, {GMPC_CLICKLABEL_SIGHANDLER_FOCUS_IN, "GMPC_CLICKLABEL_SIGHANDLER_FOCUS_IN", "focus-in"}, {GMPC_CLICKLABEL_SIGHANDLER_FOCUS_OUT, "GMPC_CLICKLABEL_SIGHANDLER_FOCUS_OUT", "focus-out"}, {GMPC_CLICKLABEL_SIGHANDLER_NUM_SIGNALS, "GMPC_CLICKLABEL_SIGHANDLER_NUM_SIGNALS", "num-signals"}, {0, NULL, NULL}};
		GType gmpc_clicklabel_sighandler_type_id;
		gmpc_clicklabel_sighandler_type_id = g_enum_register_static ("GmpcClicklabelSighandler", values);
		g_once_init_leave (&gmpc_clicklabel_sighandler_type_id__volatile, gmpc_clicklabel_sighandler_type_id);
	}
	return gmpc_clicklabel_sighandler_type_id__volatile;
}


/**
     * Constructor 
     */
static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gpointer _pango_font_description_copy0 (gpointer self) {
	return self ? pango_font_description_copy (self) : NULL;
}


static gboolean _lambda3_ (GtkWidget* source, GdkEventCrossing* event, GmpcClicklabel* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (source != NULL, FALSE);
	self->priv->mouseCursorInside = TRUE;
	result = FALSE;
	return result;
}


static gboolean __lambda3__gtk_widget_enter_notify_event (GtkWidget* _sender, GdkEventCrossing* event, gpointer self) {
	gboolean result;
	result = _lambda3_ (_sender, event, self);
	return result;
}


static gboolean _lambda4_ (GtkWidget* source, GdkEventCrossing* event, GmpcClicklabel* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (source != NULL, FALSE);
	self->priv->mouseCursorInside = FALSE;
	result = FALSE;
	return result;
}


static gboolean __lambda4__gtk_widget_leave_notify_event (GtkWidget* _sender, GdkEventCrossing* event, gpointer self) {
	gboolean result;
	result = _lambda4_ (_sender, event, self);
	return result;
}


GmpcClicklabel* gmpc_clicklabel_construct (GType object_type, const gchar* value) {
	GmpcClicklabel * self = NULL;
	PangoAttrList* _tmp0_ = NULL;
	GtkLabel* _tmp1_ = NULL;
	PangoContext* _tmp2_ = NULL;
	PangoContext* _tmp3_;
	PangoContext* fd;
	const PangoFontDescription* _tmp4_ = NULL;
	PangoFontDescription* _tmp5_;
	PangoFontDescription* pfd;
	gint _tmp6_;
	g_return_val_if_fail (value != NULL, NULL);
	self = (GmpcClicklabel*) g_object_new (object_type, NULL);
	_tmp0_ = pango_attr_list_new ();
	_pango_attr_list_unref0 (self->priv->attributes);
	self->priv->attributes = _tmp0_;
	gtk_event_box_set_visible_window ((GtkEventBox*) self, FALSE);
	_tmp1_ = (GtkLabel*) gtk_label_new (value);
	_g_object_unref0 (self->priv->label);
	self->priv->label = g_object_ref_sink (_tmp1_);
	gtk_misc_set_alignment ((GtkMisc*) self->priv->label, (gfloat) 0, 0.5f);
	_tmp2_ = gtk_widget_get_pango_context ((GtkWidget*) self->priv->label);
	_tmp3_ = _g_object_ref0 (_tmp2_);
	fd = _tmp3_;
	_tmp4_ = pango_context_get_font_description (fd);
	_tmp5_ = _pango_font_description_copy0 (_tmp4_);
	pfd = _tmp5_;
	_tmp6_ = pango_font_description_get_size (pfd);
	self->priv->size = _tmp6_;
	gmpc_clicklabel_update (self);
	gtk_label_set_attributes (self->priv->label, self->priv->attributes);
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) self->priv->label);
	g_signal_connect_object ((GtkWidget*) self, "enter-notify-event", (GCallback) __lambda3__gtk_widget_enter_notify_event, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "leave-notify-event", (GCallback) __lambda4__gtk_widget_leave_notify_event, self, 0);
	gmpc_clicklabel_set_sensitive (self, TRUE);
	_pango_font_description_free0 (pfd);
	_g_object_unref0 (fd);
	return self;
}


GmpcClicklabel* gmpc_clicklabel_new (const gchar* value) {
	return gmpc_clicklabel_construct (GMPC_TYPE_CLICKLABEL, value);
}


/**
     * Set sensitive
     */
static gboolean _lambda5_ (GtkWidget* source, GdkEventCrossing* event, GmpcClicklabel* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (source != NULL, FALSE);
	gmpc_clicklabel_set_do_underline (self, TRUE);
	result = FALSE;
	return result;
}


static gboolean __lambda5__gtk_widget_enter_notify_event (GtkWidget* _sender, GdkEventCrossing* event, gpointer self) {
	gboolean result;
	result = _lambda5_ (_sender, event, self);
	return result;
}


static gboolean _lambda6_ (GtkWidget* source, GdkEventCrossing* event, GmpcClicklabel* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (source != NULL, FALSE);
	gmpc_clicklabel_set_do_underline (self, FALSE);
	result = FALSE;
	return result;
}


static gboolean __lambda6__gtk_widget_leave_notify_event (GtkWidget* _sender, GdkEventCrossing* event, gpointer self) {
	gboolean result;
	result = _lambda6_ (_sender, event, self);
	return result;
}


static gboolean _lambda7_ (GtkWidget* source, GdkEventButton* event, GmpcClicklabel* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (source != NULL, FALSE);
	if ((*event).button == 1) {
		g_signal_emit_by_name (self, "clicked", ((*event).state & GDK_MOD1_MASK) == GDK_MOD1_MASK);
	}
	result = FALSE;
	return result;
}


static gboolean __lambda7__gtk_widget_button_release_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = _lambda7_ (_sender, event, self);
	return result;
}


static gboolean _lambda8_ (GtkWidget* source, GdkEventKey* event, GmpcClicklabel* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (source != NULL, FALSE);
	if ((*event).keyval == 65293) {
		g_signal_emit_by_name (self, "clicked", ((*event).state & GDK_MOD1_MASK) == GDK_MOD1_MASK);
	}
	result = FALSE;
	return result;
}


static gboolean __lambda8__gtk_widget_key_release_event (GtkWidget* _sender, GdkEventKey* event, gpointer self) {
	gboolean result;
	result = _lambda8_ (_sender, event, self);
	return result;
}


static gboolean _lambda9_ (GtkWidget* source, GdkEventFocus* event, GmpcClicklabel* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (source != NULL, FALSE);
	gmpc_clicklabel_set_do_underline (self, TRUE);
	result = FALSE;
	return result;
}


static gboolean __lambda9__gtk_widget_focus_in_event (GtkWidget* _sender, GdkEventFocus* event, gpointer self) {
	gboolean result;
	result = _lambda9_ (_sender, event, self);
	return result;
}


static gboolean _lambda10_ (GtkWidget* source, GdkEventFocus* event, GmpcClicklabel* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (source != NULL, FALSE);
	gmpc_clicklabel_set_do_underline (self, FALSE);
	result = FALSE;
	return result;
}


static gboolean __lambda10__gtk_widget_focus_out_event (GtkWidget* _sender, GdkEventFocus* event, gpointer self) {
	gboolean result;
	result = _lambda10_ (_sender, event, self);
	return result;
}


void gmpc_clicklabel_set_sensitive (GmpcClicklabel* self, gboolean sensitive_state) {
	g_return_if_fail (self != NULL);
	if (self->priv->sensitive == sensitive_state) {
		return;
	} else {
		if (sensitive_state == TRUE) {
			gulong _tmp0_;
			gulong _tmp1_;
			gulong _tmp2_;
			gulong _tmp3_;
			gulong _tmp4_;
			gulong _tmp5_;
			_tmp0_ = g_signal_connect_object ((GtkWidget*) self, "enter-notify-event", (GCallback) __lambda5__gtk_widget_enter_notify_event, self, 0);
			self->priv->handlers[GMPC_CLICKLABEL_SIGHANDLER_ENTER_NOTIFY] = _tmp0_;
			_tmp1_ = g_signal_connect_object ((GtkWidget*) self, "leave-notify-event", (GCallback) __lambda6__gtk_widget_leave_notify_event, self, 0);
			self->priv->handlers[GMPC_CLICKLABEL_SIGHANDLER_LEAVE_NOTIFY] = _tmp1_;
			_tmp2_ = g_signal_connect_object ((GtkWidget*) self, "button-release-event", (GCallback) __lambda7__gtk_widget_button_release_event, self, 0);
			self->priv->handlers[GMPC_CLICKLABEL_SIGHANDLER_BUTTON_RELEASE] = _tmp2_;
			_tmp3_ = g_signal_connect_object ((GtkWidget*) self, "key-release-event", (GCallback) __lambda8__gtk_widget_key_release_event, self, 0);
			self->priv->handlers[GMPC_CLICKLABEL_SIGHANDLER_KEY_RELEASE] = _tmp3_;
			_tmp4_ = g_signal_connect_object ((GtkWidget*) self, "focus-in-event", (GCallback) __lambda9__gtk_widget_focus_in_event, self, 0);
			self->priv->handlers[GMPC_CLICKLABEL_SIGHANDLER_FOCUS_IN] = _tmp4_;
			_tmp5_ = g_signal_connect_object ((GtkWidget*) self, "focus-out-event", (GCallback) __lambda10__gtk_widget_focus_out_event, self, 0);
			self->priv->handlers[GMPC_CLICKLABEL_SIGHANDLER_FOCUS_OUT] = _tmp5_;
			if (self->priv->mouseCursorInside) {
				gmpc_clicklabel_set_do_underline (self, TRUE);
			}
			self->priv->sensitive = TRUE;
		} else {
			{
				gint i;
				i = 0;
				{
					gboolean _tmp6_;
					_tmp6_ = TRUE;
					while (TRUE) {
						if (!_tmp6_) {
							i++;
						}
						_tmp6_ = FALSE;
						if (!(i < GMPC_CLICKLABEL_SIGHANDLER_NUM_SIGNALS)) {
							break;
						}
						g_signal_handler_disconnect ((GObject*) self, self->priv->handlers[i]);
					}
				}
			}
			gmpc_clicklabel_set_do_underline (self, FALSE);
			self->priv->sensitive = FALSE;
		}
	}
}


/**
     * Get sensitivity state
     */
gboolean gmpc_clicklabel_get_sensitive (GmpcClicklabel* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->sensitive;
	return result;
}


/**
     * Set font size 
     */
void gmpc_clicklabel_font_size (GmpcClicklabel* self, gint nsize) {
	g_return_if_fail (self != NULL);
	self->priv->size = nsize * PANGO_SCALE;
	gmpc_clicklabel_update (self);
}


/**
     * set ellipsize
     */
void gmpc_clicklabel_set_ellipsize (GmpcClicklabel* self, PangoEllipsizeMode mode) {
	g_return_if_fail (self != NULL);
	gtk_label_set_ellipsize (self->priv->label, mode);
}


/**
     * Set label text
     */
void gmpc_clicklabel_set_text (GmpcClicklabel* self, const gchar* value) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (value != NULL);
	gtk_label_set_text (self->priv->label, value);
}


void gmpc_clicklabel_set_do_underline (GmpcClicklabel* self, gboolean val) {
	g_return_if_fail (self != NULL);
	self->priv->underline = val;
	gmpc_clicklabel_update (self);
}


/**
     * Set do italic
     */
void gmpc_clicklabel_set_do_italic (GmpcClicklabel* self, gboolean val) {
	g_return_if_fail (self != NULL);
	self->priv->italic = val;
	gmpc_clicklabel_update (self);
}


void gmpc_clicklabel_set_do_bold (GmpcClicklabel* self, gboolean val) {
	g_return_if_fail (self != NULL);
	self->priv->bold = val;
	gmpc_clicklabel_update (self);
}


/**
     * Private functions
     */
static void gmpc_clicklabel_update (GmpcClicklabel* self) {
	PangoAttribute* attr;
	PangoAttribute* _tmp2_;
	PangoAttribute* _tmp5_;
	PangoAttribute* _tmp8_;
	PangoAttrSize* _tmp9_ = NULL;
	PangoAttribute* _tmp10_;
	g_return_if_fail (self != NULL);
	attr = NULL;
	if (self->priv->italic) {
		PangoAttribute* _tmp0_ = NULL;
		_tmp0_ = pango_attr_style_new (PANGO_STYLE_ITALIC);
		_pango_attribute_destroy0 (attr);
		attr = _tmp0_;
	} else {
		PangoAttribute* _tmp1_ = NULL;
		_tmp1_ = pango_attr_style_new (PANGO_STYLE_NORMAL);
		_pango_attribute_destroy0 (attr);
		attr = _tmp1_;
	}
	attr->start_index = (guint) 0;
	attr->end_index = (guint) (-1);
	_tmp2_ = attr;
	attr = NULL;
	pango_attr_list_change (self->priv->attributes, _tmp2_);
	if (self->priv->bold) {
		PangoAttribute* _tmp3_ = NULL;
		_tmp3_ = pango_attr_weight_new (PANGO_WEIGHT_BOLD);
		_pango_attribute_destroy0 (attr);
		attr = _tmp3_;
	} else {
		PangoAttribute* _tmp4_ = NULL;
		_tmp4_ = pango_attr_weight_new (PANGO_WEIGHT_NORMAL);
		_pango_attribute_destroy0 (attr);
		attr = _tmp4_;
	}
	attr->start_index = (guint) 0;
	attr->end_index = (guint) (-1);
	_tmp5_ = attr;
	attr = NULL;
	pango_attr_list_change (self->priv->attributes, _tmp5_);
	if (self->priv->underline) {
		PangoAttribute* _tmp6_ = NULL;
		_tmp6_ = pango_attr_underline_new (PANGO_UNDERLINE_SINGLE);
		_pango_attribute_destroy0 (attr);
		attr = _tmp6_;
	} else {
		PangoAttribute* _tmp7_ = NULL;
		_tmp7_ = pango_attr_underline_new (PANGO_UNDERLINE_NONE);
		_pango_attribute_destroy0 (attr);
		attr = _tmp7_;
	}
	attr->start_index = (guint) 0;
	attr->end_index = (guint) (-1);
	_tmp8_ = attr;
	attr = NULL;
	pango_attr_list_change (self->priv->attributes, _tmp8_);
	_tmp9_ = (PangoAttrSize*) pango_attr_size_new (self->priv->size);
	_pango_attribute_destroy0 (attr);
	attr = (PangoAttribute*) _tmp9_;
	attr->start_index = (guint) 0;
	attr->end_index = (guint) (-1);
	_tmp10_ = attr;
	attr = NULL;
	pango_attr_list_change (self->priv->attributes, _tmp10_);
	gtk_label_set_attributes (self->priv->label, self->priv->attributes);
	_pango_attribute_destroy0 (attr);
}


static void gmpc_clicklabel_class_init (GmpcClicklabelClass * klass) {
	gmpc_clicklabel_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GmpcClicklabelPrivate));
	G_OBJECT_CLASS (klass)->finalize = gmpc_clicklabel_finalize;
	g_signal_new ("clicked", GMPC_TYPE_CLICKLABEL, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__BOOLEAN, G_TYPE_NONE, 1, G_TYPE_BOOLEAN);
}


static void gmpc_clicklabel_instance_init (GmpcClicklabel * self) {
	self->priv = GMPC_CLICKLABEL_GET_PRIVATE (self);
	self->priv->label = NULL;
	self->priv->sensitive = FALSE;
	self->priv->size = 10 * PANGO_SCALE;
	self->priv->italic = FALSE;
	self->priv->bold = FALSE;
	self->priv->underline = FALSE;
	self->priv->attributes = NULL;
	self->priv->mouseCursorInside = FALSE;
}


static void gmpc_clicklabel_finalize (GObject* obj) {
	GmpcClicklabel * self;
	self = GMPC_CLICKLABEL (obj);
	_g_object_unref0 (self->priv->label);
	_pango_attr_list_unref0 (self->priv->attributes);
	G_OBJECT_CLASS (gmpc_clicklabel_parent_class)->finalize (obj);
}


GType gmpc_clicklabel_get_type (void) {
	static volatile gsize gmpc_clicklabel_type_id__volatile = 0;
	if (g_once_init_enter (&gmpc_clicklabel_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GmpcClicklabelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gmpc_clicklabel_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GmpcClicklabel), 0, (GInstanceInitFunc) gmpc_clicklabel_instance_init, NULL };
		GType gmpc_clicklabel_type_id;
		gmpc_clicklabel_type_id = g_type_register_static (GTK_TYPE_EVENT_BOX, "GmpcClicklabel", &g_define_type_info, 0);
		g_once_init_leave (&gmpc_clicklabel_type_id__volatile, gmpc_clicklabel_type_id);
	}
	return gmpc_clicklabel_type_id__volatile;
}



