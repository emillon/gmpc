/* gmpc-widgets-popupmenu.c generated by valac 0.12.0, the Vala compiler
 * generated from gmpc-widgets-popupmenu.vala, do not modify */

/* Gnome Music Player Client (GMPC)
 * Copyright (C) 2004-2011 Qball Cow <qball@gmpclient.org>
 * Project homepage: http://gmpclient.org/
 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/

#include <glib.h>
#include <glib-object.h>
#include "gmpc-extras.h"
#include <gdk/gdk.h>
#include <gtk/gtk.h>


struct _PopupMenuPrivate {
	gint x;
	gint y;
	gint width;
	gint height;
};


static gpointer popup_menu_parent_class = NULL;

#define POPUP_MENU_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_POPUP_MENU, PopupMenuPrivate))
enum  {
	POPUP_MENU_DUMMY_PROPERTY
};
static void popup_menu_sig_realize (PopupMenu* self, GdkRectangle* alloc);
static void popup_menu_move_it (PopupMenu* self);
static GObject * popup_menu_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static gboolean _lambda24_ (GtkWidget* source, GdkEventCrossing* event, PopupMenu* self);
static gboolean __lambda24__gtk_widget_leave_notify_event (GtkWidget* _sender, GdkEventCrossing* event, gpointer self);
static void _popup_menu_sig_realize_gtk_widget_size_allocate (GtkWidget* _sender, GdkRectangle* allocation, gpointer self);
static void popup_menu_finalize (GObject* obj);


static void popup_menu_sig_realize (PopupMenu* self, GdkRectangle* alloc) {
	g_return_if_fail (self != NULL);
	self->priv->width = (*alloc).width;
	self->priv->height = (*alloc).height;
}


static void popup_menu_move_it (PopupMenu* self) {
	g_return_if_fail (self != NULL);
	gtk_window_move ((GtkWindow*) self, self->priv->x - (self->priv->width / 2), self->priv->y - (self->priv->height / 2));
}


void popup_menu_popup (PopupMenu* self, GdkEventButton* event) {
	g_return_if_fail (self != NULL);
	self->priv->x = (gint) (*event).x_root;
	self->priv->y = (gint) (*event).y_root;
	gtk_widget_show ((GtkWidget*) self);
	popup_menu_move_it (self);
}


PopupMenu* popup_menu_construct (GType object_type) {
	PopupMenu * self = NULL;
	self = (PopupMenu*) g_object_new (object_type, NULL);
	return self;
}


PopupMenu* popup_menu_new (void) {
	return popup_menu_construct (TYPE_POPUP_MENU);
}


static gboolean _lambda24_ (GtkWidget* source, GdkEventCrossing* event, PopupMenu* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (source != NULL, FALSE);
	gtk_object_destroy ((GtkObject*) self);
}


static gboolean __lambda24__gtk_widget_leave_notify_event (GtkWidget* _sender, GdkEventCrossing* event, gpointer self) {
	gboolean result;
	result = _lambda24_ (_sender, event, self);
	return result;
}


static void _popup_menu_sig_realize_gtk_widget_size_allocate (GtkWidget* _sender, GdkRectangle* allocation, gpointer self) {
	popup_menu_sig_realize (self, allocation);
}


static GObject * popup_menu_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	PopupMenu * self;
	parent_class = G_OBJECT_CLASS (popup_menu_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = POPUP_MENU (obj);
	g_object_set ((GtkWindow*) self, "type", GTK_WINDOW_POPUP, NULL);
	gtk_widget_set_no_show_all ((GtkWidget*) self, TRUE);
	gtk_window_set_resizable ((GtkWindow*) self, FALSE);
	g_signal_connect_object ((GtkWidget*) self, "leave-notify-event", (GCallback) __lambda24__gtk_widget_leave_notify_event, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "size-allocate", (GCallback) _popup_menu_sig_realize_gtk_widget_size_allocate, self, 0);
	return obj;
}


static void popup_menu_class_init (PopupMenuClass * klass) {
	popup_menu_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (PopupMenuPrivate));
	G_OBJECT_CLASS (klass)->constructor = popup_menu_constructor;
	G_OBJECT_CLASS (klass)->finalize = popup_menu_finalize;
}


static void popup_menu_instance_init (PopupMenu * self) {
	self->priv = POPUP_MENU_GET_PRIVATE (self);
	self->priv->x = 0;
	self->priv->y = 0;
	self->priv->width = 0;
	self->priv->height = 0;
}


static void popup_menu_finalize (GObject* obj) {
	PopupMenu * self;
	self = POPUP_MENU (obj);
	G_OBJECT_CLASS (popup_menu_parent_class)->finalize (obj);
}


GType popup_menu_get_type (void) {
	static volatile gsize popup_menu_type_id__volatile = 0;
	if (g_once_init_enter (&popup_menu_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PopupMenuClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) popup_menu_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PopupMenu), 0, (GInstanceInitFunc) popup_menu_instance_init, NULL };
		GType popup_menu_type_id;
		popup_menu_type_id = g_type_register_static (GTK_TYPE_WINDOW, "PopupMenu", &g_define_type_info, 0);
		g_once_init_leave (&popup_menu_type_id__volatile, popup_menu_type_id);
	}
	return popup_menu_type_id__volatile;
}



