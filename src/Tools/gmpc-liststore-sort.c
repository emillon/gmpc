/* gmpc-liststore-sort.c generated by valac 0.12.0, the Vala compiler
 * generated from gmpc-liststore-sort.vala, do not modify */

/* Gnome Music Player Client (GMPC)
 * Copyright (C) 2004-2011 Qball Cow <qball@gmpclient.org>
 * Project homepage: http://gmpclient.org/
 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/

#include <glib.h>
#include <glib-object.h>
#include "gmpc-extras.h"
#include <gtk/gtk.h>
#include <gtktransition.h>

#define _gtk_tree_path_free0(var) ((var == NULL) ? NULL : (var = (gtk_tree_path_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))


static gpointer gmpc_tools_liststore_sort_parent_class = NULL;
static GtkTreeDragSourceIface* gmpc_tools_liststore_sort_gtk_tree_drag_source_parent_iface = NULL;
static GtkTreeDragDestIface* gmpc_tools_liststore_sort_gtk_tree_drag_dest_parent_iface = NULL;

enum  {
	GMPC_TOOLS_LISTSTORE_SORT_DUMMY_PROPERTY
};
#define GMPC_TOOLS_LISTSTORE_SORT_use_transition TRUE
static gboolean gmpc_tools_liststore_sort_real_row_draggable (GtkTreeDragSource* base, GtkTreePath* path);
static gboolean gmpc_tools_liststore_sort_real_drag_data_get (GtkTreeDragSource* base, GtkTreePath* path, GtkSelectionData* selection_data);
static gboolean gmpc_tools_liststore_sort_real_drag_data_delete (GtkTreeDragSource* base, GtkTreePath* path);
static gboolean gmpc_tools_liststore_sort_real_drag_data_received (GtkTreeDragDest* base, GtkTreePath* dest, GtkSelectionData* selection_data);


static gboolean gmpc_tools_liststore_sort_real_row_draggable (GtkTreeDragSource* base, GtkTreePath* path) {
	GmpcToolsListstoreSort * self;
	gboolean result = FALSE;
	self = (GmpcToolsListstoreSort*) base;
	g_return_val_if_fail (path != NULL, FALSE);
	result = TRUE;
	return result;
}


static gboolean gmpc_tools_liststore_sort_real_drag_data_get (GtkTreeDragSource* base, GtkTreePath* path, GtkSelectionData* selection_data) {
	GmpcToolsListstoreSort * self;
	gboolean result = FALSE;
	self = (GmpcToolsListstoreSort*) base;
	g_return_val_if_fail (path != NULL, FALSE);
	g_return_val_if_fail (selection_data != NULL, FALSE);
	result = FALSE;
	return result;
}


static gboolean gmpc_tools_liststore_sort_real_drag_data_delete (GtkTreeDragSource* base, GtkTreePath* path) {
	GmpcToolsListstoreSort * self;
	gboolean result = FALSE;
	self = (GmpcToolsListstoreSort*) base;
	g_return_val_if_fail (path != NULL, FALSE);
	result = TRUE;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gpointer _gtk_tree_path_copy0 (gpointer self) {
	return self ? gtk_tree_path_copy (self) : NULL;
}


static gboolean gmpc_tools_liststore_sort_real_drag_data_received (GtkTreeDragDest* base, GtkTreePath* dest, GtkSelectionData* selection_data) {
	GmpcToolsListstoreSort * self;
	gboolean result = FALSE;
	GtkTreeModel* model = NULL;
	GtkTreePath* path;
	GtkTreeModel* _tmp0_ = NULL;
	GtkTreePath* _tmp1_ = NULL;
	gboolean _tmp2_;
	GtkTreeModel* _tmp3_;
	GtkTreePath* _tmp4_;
	self = (GmpcToolsListstoreSort*) base;
	g_return_val_if_fail (dest != NULL, FALSE);
	g_return_val_if_fail (selection_data != NULL, FALSE);
	path = NULL;
	if (dest == NULL) {
		result = FALSE;
		_gtk_tree_path_free0 (path);
		_g_object_unref0 (model);
		return result;
	}
	_tmp2_ = gtk_tree_get_row_drag_data (selection_data, &_tmp0_, &_tmp1_);
	_g_object_unref0 (model);
	_tmp3_ = _g_object_ref0 (_tmp0_);
	model = _tmp3_;
	_gtk_tree_path_free0 (path);
	_tmp4_ = _gtk_tree_path_copy0 (_tmp1_);
	path = _tmp4_;
	if (_tmp2_) {
		GtkTreeIter dest_iter = {0};
		GtkTreeIter source_iter = {0};
		GtkTreeIter _tmp5_ = {0};
		gboolean _tmp6_;
		gboolean dest_v;
		GtkTreeIter _tmp7_ = {0};
		gboolean _tmp8_;
		gboolean source_v;
		_tmp6_ = gtk_tree_model_get_iter (model, &_tmp5_, dest);
		dest_iter = _tmp5_;
		dest_v = _tmp6_;
		_tmp8_ = gtk_tree_model_get_iter (model, &_tmp7_, path);
		source_iter = _tmp7_;
		source_v = _tmp8_;
		if (source_v) {
			if (dest_v) {
				gtk_list_store_move_before ((GtkListStore*) self, &source_iter, &dest_iter);
			} else {
				gtk_list_store_move_before ((GtkListStore*) self, &source_iter, NULL);
			}
		}
		result = TRUE;
		_gtk_tree_path_free0 (path);
		_g_object_unref0 (model);
		return result;
	}
	result = FALSE;
	_gtk_tree_path_free0 (path);
	_g_object_unref0 (model);
	return result;
}


GmpcToolsListstoreSort* gmpc_tools_liststore_sort_construct (GType object_type) {
	GmpcToolsListstoreSort * self = NULL;
	self = (GmpcToolsListstoreSort*) g_object_new (object_type, NULL);
	return self;
}


GmpcToolsListstoreSort* gmpc_tools_liststore_sort_new (void) {
	return gmpc_tools_liststore_sort_construct (GMPC_TOOLS_TYPE_LISTSTORE_SORT);
}


static void gmpc_tools_liststore_sort_class_init (GmpcToolsListstoreSortClass * klass) {
	gmpc_tools_liststore_sort_parent_class = g_type_class_peek_parent (klass);
}


static void gmpc_tools_liststore_sort_gtk_tree_drag_source_interface_init (GtkTreeDragSourceIface * iface) {
	gmpc_tools_liststore_sort_gtk_tree_drag_source_parent_iface = g_type_interface_peek_parent (iface);
	iface->row_draggable = (gboolean (*)(GtkTreeDragSource* ,GtkTreePath*)) gmpc_tools_liststore_sort_real_row_draggable;
	iface->drag_data_get = (gboolean (*)(GtkTreeDragSource* ,GtkTreePath* ,GtkSelectionData*)) gmpc_tools_liststore_sort_real_drag_data_get;
	iface->drag_data_delete = (gboolean (*)(GtkTreeDragSource* ,GtkTreePath*)) gmpc_tools_liststore_sort_real_drag_data_delete;
}


static void gmpc_tools_liststore_sort_gtk_tree_drag_dest_interface_init (GtkTreeDragDestIface * iface) {
	gmpc_tools_liststore_sort_gtk_tree_drag_dest_parent_iface = g_type_interface_peek_parent (iface);
	iface->drag_data_received = (gboolean (*)(GtkTreeDragDest* ,GtkTreePath* ,GtkSelectionData*)) gmpc_tools_liststore_sort_real_drag_data_received;
}


static void gmpc_tools_liststore_sort_instance_init (GmpcToolsListstoreSort * self) {
}


GType gmpc_tools_liststore_sort_get_type (void) {
	static volatile gsize gmpc_tools_liststore_sort_type_id__volatile = 0;
	if (g_once_init_enter (&gmpc_tools_liststore_sort_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GmpcToolsListstoreSortClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gmpc_tools_liststore_sort_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GmpcToolsListstoreSort), 0, (GInstanceInitFunc) gmpc_tools_liststore_sort_instance_init, NULL };
		static const GInterfaceInfo gtk_tree_drag_source_info = { (GInterfaceInitFunc) gmpc_tools_liststore_sort_gtk_tree_drag_source_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		static const GInterfaceInfo gtk_tree_drag_dest_info = { (GInterfaceInitFunc) gmpc_tools_liststore_sort_gtk_tree_drag_dest_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType gmpc_tools_liststore_sort_type_id;
		gmpc_tools_liststore_sort_type_id = g_type_register_static (GTK_TYPE_LIST_STORE, "GmpcToolsListstoreSort", &g_define_type_info, 0);
		g_type_add_interface_static (gmpc_tools_liststore_sort_type_id, GTK_TYPE_TREE_DRAG_SOURCE, &gtk_tree_drag_source_info);
		g_type_add_interface_static (gmpc_tools_liststore_sort_type_id, GTK_TYPE_TREE_DRAG_DEST, &gtk_tree_drag_dest_info);
		g_once_init_leave (&gmpc_tools_liststore_sort_type_id__volatile, gmpc_tools_liststore_sort_type_id);
	}
	return gmpc_tools_liststore_sort_type_id__volatile;
}



