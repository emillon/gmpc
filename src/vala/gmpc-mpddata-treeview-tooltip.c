/* gmpc-mpddata-treeview-tooltip.c generated by valac 0.12.0, the Vala compiler
 * generated from gmpc-mpddata-treeview-tooltip.vala, do not modify */

/* Gnome Music Player Client (GMPC)
 * Copyright (C) 2004-2011 Qball Cow <qball@gmpclient.org>
 * Project homepage: http://gmpclient.org/
 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gtktransition.h>
#include <stdlib.h>
#include <string.h>
#include <config.h>
#include "gmpc-extras.h"
#include <metadata.h>
#include <plugin.h>
#include <config1.h>
#include <libmpd/libmpdclient.h>
#include <libmpd/libmpd.h>
#include <misc.h>
#include <main.h>
#include <gmpc-meta-watcher.h>
#include <gdk-pixbuf/gdk-pixdata.h>

#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _gtk_tree_path_free0(var) ((var == NULL) ? NULL : (var = (gtk_tree_path_free (var), NULL)))
#define _mpd_freeSong0(var) ((var == NULL) ? NULL : (var = (mpd_freeSong (var), NULL)))
#define _meta_data_free0(var) ((var == NULL) ? NULL : (var = (meta_data_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _GmpcMpdDataTreeviewTooltipPrivate {
	GtkTreeView* par_widget;
	GtkImage* image;
	gchar* checksum;
};


static gpointer gmpc_mpd_data_treeview_tooltip_parent_class = NULL;

#define use_transition_mtt TRUE
#define some_unique_name_mtt VERSION
#define GMPC_MPD_DATA_TREEVIEW_TOOLTIP_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GMPC_MPD_DATA_TREEVIEW_TYPE_TOOLTIP, GmpcMpdDataTreeviewTooltipPrivate))
enum  {
	GMPC_MPD_DATA_TREEVIEW_TOOLTIP_DUMMY_PROPERTY
};
static gboolean gmpc_mpd_data_treeview_tooltip_query_tooltip_callback (GmpcMpdDataTreeviewTooltip* self, gint x, gint y, gboolean keyboard_tip, GtkTooltip* tooltip);
static void gmpc_mpd_data_treeview_tooltip_metadata_changed (GmpcMpdDataTreeviewTooltip* self, GmpcMetaWatcher* gmw2, const mpd_Song* song, MetaDataType type, MetaDataResult _result_, const MetaData* met);
static gboolean _gmpc_mpd_data_treeview_tooltip_query_tooltip_callback_gtk_widget_query_tooltip (GtkWidget* _sender, gint x, gint y, gboolean keyboard_tooltip, GtkTooltip* tooltip, gpointer self);
static void _gmpc_mpd_data_treeview_tooltip_metadata_changed_gmpc_meta_watcher_data_changed (GmpcMetaWatcher* _sender, const mpd_Song* song, MetaDataType type, MetaDataResult _result_, const MetaData* met, gpointer self);
static GObject * gmpc_mpd_data_treeview_tooltip_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void gmpc_mpd_data_treeview_tooltip_finalize (GObject* obj);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gpointer _gtk_tree_path_copy0 (gpointer self) {
	return self ? gtk_tree_path_copy (self) : NULL;
}


static gboolean gmpc_mpd_data_treeview_tooltip_query_tooltip_callback (GmpcMpdDataTreeviewTooltip* self, gint x, gint y, gboolean keyboard_tip, GtkTooltip* tooltip) {
	gboolean result = FALSE;
	gchar* tag;
	gint row_type;
	GtkTreePath* path;
	GtkTreeIter iter = {0};
	GtkTreeModel* _tmp0_ = NULL;
	GtkTreeModel* _tmp1_;
	GtkTreeModel* model;
	gint _tmp2_;
	gboolean _tmp3_ = FALSE;
	gint _tmp4_;
	gint _tmp5_;
	GtkTreeModel* _tmp6_ = NULL;
	GtkTreePath* _tmp7_ = NULL;
	GtkTreeIter _tmp8_ = {0};
	gboolean _tmp9_;
	GtkTreeModel* _tmp10_;
	GtkTreePath* _tmp11_;
	mpd_Song* _tmp12_ = NULL;
	mpd_Song* song;
	gchar* _tmp18_ = NULL;
	gchar* new_check;
	gboolean _tmp19_ = FALSE;
	GtkImageType _tmp23_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (tooltip != NULL, FALSE);
	tag = NULL;
	row_type = 0;
	path = NULL;
	_tmp0_ = gtk_tree_view_get_model (self->priv->par_widget);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	model = _tmp1_;
	_tmp2_ = cfg_get_single_value_as_int_with_default (config, "GmpcTreeView", "show-tooltip", 1);
	if (_tmp2_ != 1) {
		result = FALSE;
		_g_object_unref0 (model);
		_gtk_tree_path_free0 (path);
		_g_free0 (tag);
		return result;
	}
	if (self->mtype != META_ARTIST_ART) {
		_tmp3_ = self->mtype != META_ALBUM_ART;
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		_g_free0 (self->priv->checksum);
		self->priv->checksum = NULL;
		result = FALSE;
		_g_object_unref0 (model);
		_gtk_tree_path_free0 (path);
		_g_free0 (tag);
		return result;
	}
	_tmp9_ = gtk_tree_view_get_tooltip_context (self->priv->par_widget, &_tmp4_, &_tmp5_, keyboard_tip, &_tmp6_, &_tmp7_, &_tmp8_);
	x = _tmp4_;
	y = _tmp5_;
	_g_object_unref0 (model);
	_tmp10_ = _g_object_ref0 (_tmp6_);
	model = _tmp10_;
	_gtk_tree_path_free0 (path);
	_tmp11_ = _gtk_tree_path_copy0 (_tmp7_);
	path = _tmp11_;
	iter = _tmp8_;
	if (!_tmp9_) {
		_g_free0 (self->priv->checksum);
		self->priv->checksum = NULL;
		result = FALSE;
		_g_object_unref0 (model);
		_gtk_tree_path_free0 (path);
		_g_free0 (tag);
		return result;
	}
	_tmp12_ = mpd_newSong ();
	song = _tmp12_;
	gtk_tree_model_get (model, &iter, 26, &row_type, -1);
	if (row_type == MPD_DATA_TYPE_SONG) {
		gchar* album;
		gchar* _tmp13_;
		gchar* _tmp14_;
		album = NULL;
		gtk_tree_model_get (model, &iter, 5, &tag, 6, &album, -1);
		_tmp13_ = g_strdup (tag);
		_g_free0 (song->artist);
		song->artist = _tmp13_;
		_tmp14_ = g_strdup (album);
		_g_free0 (song->album);
		song->album = _tmp14_;
		_g_free0 (album);
	} else {
		if (row_type == MPD_DATA_TYPE_TAG) {
			if (self->mtype == META_ARTIST_ART) {
				gchar* _tmp15_;
				gtk_tree_model_get (model, &iter, 7, &tag, -1);
				_tmp15_ = g_strdup (tag);
				_g_free0 (song->artist);
				song->artist = _tmp15_;
			} else {
				if (self->mtype == META_ALBUM_ART) {
					gchar* _tmp16_;
					gchar* _tmp17_;
					gtk_tree_model_get (model, &iter, 7, &tag, -1);
					_tmp16_ = g_strdup (self->request_artist);
					_g_free0 (song->artist);
					song->artist = _tmp16_;
					_tmp17_ = g_strdup (tag);
					_g_free0 (song->album);
					song->album = _tmp17_;
				}
			}
		}
	}
	_tmp18_ = mpd_song_checksum (song);
	new_check = _tmp18_;
	if (g_strcmp0 (new_check, self->priv->checksum) != 0) {
		_tmp19_ = self->priv->checksum != NULL;
	} else {
		_tmp19_ = FALSE;
	}
	if (_tmp19_) {
		_g_free0 (self->priv->checksum);
		self->priv->checksum = NULL;
		result = FALSE;
		_g_free0 (new_check);
		_mpd_freeSong0 (song);
		_g_object_unref0 (model);
		_gtk_tree_path_free0 (path);
		_g_free0 (tag);
		return result;
	}
	if (g_strcmp0 (new_check, self->priv->checksum) != 0) {
		gchar* _tmp20_;
		MetaData* met;
		MetaData* _tmp21_ = NULL;
		MetaDataResult _tmp22_;
		MetaDataResult _result_;
		_tmp20_ = g_strdup (new_check);
		_g_free0 (self->priv->checksum);
		self->priv->checksum = _tmp20_;
		met = NULL;
		_tmp22_ = gmpc_meta_watcher_get_meta_path (gmw, song, self->mtype, &_tmp21_);
		_meta_data_free0 (met);
		met = _tmp21_;
		_result_ = _tmp22_;
		gmpc_mpd_data_treeview_tooltip_metadata_changed (self, gmw, song, self->mtype, _result_, met);
		_meta_data_free0 (met);
	}
	_tmp23_ = gtk_image_get_storage_type (self->priv->image);
	if (_tmp23_ == GTK_IMAGE_EMPTY) {
		result = FALSE;
		_g_free0 (new_check);
		_mpd_freeSong0 (song);
		_g_object_unref0 (model);
		_gtk_tree_path_free0 (path);
		_g_free0 (tag);
		return result;
	}
	result = TRUE;
	_g_free0 (new_check);
	_mpd_freeSong0 (song);
	_g_object_unref0 (model);
	_gtk_tree_path_free0 (path);
	_g_free0 (tag);
	return result;
}


static void gmpc_mpd_data_treeview_tooltip_metadata_changed (GmpcMpdDataTreeviewTooltip* self, GmpcMetaWatcher* gmw2, const mpd_Song* song, MetaDataType type, MetaDataResult _result_, const MetaData* met) {
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gboolean _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (gmw2 != NULL);
	g_return_if_fail (song != NULL);
	if (type != self->mtype) {
		return;
	}
	_tmp0_ = mpd_song_checksum (song);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_strcmp0 (self->priv->checksum, _tmp1_) != 0;
	_g_free0 (_tmp1_);
	if (_tmp2_) {
		return;
	}
	if (_result_ == META_DATA_UNAVAILABLE) {
		gtk_image_clear (self->priv->image);
	} else {
		if (_result_ == META_DATA_FETCHING) {
			gtk_image_clear (self->priv->image);
		} else {
			if (_result_ == META_DATA_AVAILABLE) {
				if (met->content_type == META_DATA_CONTENT_URI) {
					const gchar* _tmp3_ = NULL;
					GdkPixbuf* _tmp4_ = NULL;
					GdkPixbuf* pb;
					_tmp3_ = meta_data_get_uri (met);
					_tmp4_ = gdk_pixbuf_new_from_file_at_scale (_tmp3_, 150, 150, TRUE, &_inner_error_);
					pb = _tmp4_;
					if (_inner_error_ != NULL) {
						goto __catch27_g_error;
					}
					gtk_image_set_from_pixbuf (self->priv->image, pb);
					_g_object_unref0 (pb);
					goto __finally27;
					__catch27_g_error:
					{
						GError * e;
						e = _inner_error_;
						_inner_error_ = NULL;
						gtk_image_clear (self->priv->image);
						_g_error_free0 (e);
					}
					__finally27:
					if (_inner_error_ != NULL) {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				} else {
					gtk_image_clear (self->priv->image);
				}
			}
		}
	}
}


static gboolean _gmpc_mpd_data_treeview_tooltip_query_tooltip_callback_gtk_widget_query_tooltip (GtkWidget* _sender, gint x, gint y, gboolean keyboard_tooltip, GtkTooltip* tooltip, gpointer self) {
	gboolean result;
	result = gmpc_mpd_data_treeview_tooltip_query_tooltip_callback (self, x, y, keyboard_tooltip, tooltip);
	return result;
}


static void _gmpc_mpd_data_treeview_tooltip_metadata_changed_gmpc_meta_watcher_data_changed (GmpcMetaWatcher* _sender, const mpd_Song* song, MetaDataType type, MetaDataResult _result_, const MetaData* met, gpointer self) {
	gmpc_mpd_data_treeview_tooltip_metadata_changed (self, _sender, song, type, _result_, met);
}


GmpcMpdDataTreeviewTooltip* gmpc_mpd_data_treeview_tooltip_construct (GType object_type, GtkTreeView* pw, MetaDataType type) {
	GmpcMpdDataTreeviewTooltip * self = NULL;
	GtkTreeView* _tmp0_;
	GtkImage* _tmp1_ = NULL;
	GtkStyle* _tmp2_ = NULL;
	g_return_val_if_fail (pw != NULL, NULL);
	self = (GmpcMpdDataTreeviewTooltip*) g_object_new (object_type, NULL);
	gtk_window_set_resizable ((GtkWindow*) self, FALSE);
	_tmp0_ = _g_object_ref0 (pw);
	_g_object_unref0 (self->priv->par_widget);
	self->priv->par_widget = _tmp0_;
	g_signal_connect_object ((GtkWidget*) pw, "query-tooltip", (GCallback) _gmpc_mpd_data_treeview_tooltip_query_tooltip_callback_gtk_widget_query_tooltip, self, 0);
	gtk_widget_set_tooltip_window ((GtkWidget*) self->priv->par_widget, (GtkWindow*) self);
	_tmp1_ = (GtkImage*) gtk_image_new ();
	_g_object_unref0 (self->priv->image);
	self->priv->image = g_object_ref_sink (_tmp1_);
	gtk_widget_show ((GtkWidget*) self->priv->image);
	self->mtype = type;
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) self->priv->image);
	gtk_container_set_border_width ((GtkContainer*) self, (guint) 2);
	_tmp2_ = gtk_widget_get_style ((GtkWidget*) pw);
	gtk_widget_modify_bg ((GtkWidget*) self, GTK_STATE_NORMAL, &_tmp2_->black);
	g_signal_connect_object (gmw, "data-changed", (GCallback) _gmpc_mpd_data_treeview_tooltip_metadata_changed_gmpc_meta_watcher_data_changed, self, 0);
	return self;
}


GmpcMpdDataTreeviewTooltip* gmpc_mpd_data_treeview_tooltip_new (GtkTreeView* pw, MetaDataType type) {
	return gmpc_mpd_data_treeview_tooltip_construct (GMPC_MPD_DATA_TREEVIEW_TYPE_TOOLTIP, pw, type);
}


static GObject * gmpc_mpd_data_treeview_tooltip_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	GmpcMpdDataTreeviewTooltip * self;
	parent_class = G_OBJECT_CLASS (gmpc_mpd_data_treeview_tooltip_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = GMPC_MPD_DATA_TREEVIEW_TOOLTIP (obj);
	g_object_set ((GtkWindow*) self, "type", GTK_WINDOW_POPUP, NULL);
	return obj;
}


static void gmpc_mpd_data_treeview_tooltip_class_init (GmpcMpdDataTreeviewTooltipClass * klass) {
	gmpc_mpd_data_treeview_tooltip_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GmpcMpdDataTreeviewTooltipPrivate));
	G_OBJECT_CLASS (klass)->constructor = gmpc_mpd_data_treeview_tooltip_constructor;
	G_OBJECT_CLASS (klass)->finalize = gmpc_mpd_data_treeview_tooltip_finalize;
}


static void gmpc_mpd_data_treeview_tooltip_instance_init (GmpcMpdDataTreeviewTooltip * self) {
	self->priv = GMPC_MPD_DATA_TREEVIEW_TOOLTIP_GET_PRIVATE (self);
	self->priv->par_widget = NULL;
	self->priv->image = NULL;
	self->mtype = META_ARTIST_ART;
	self->request_artist = NULL;
	self->priv->checksum = NULL;
}


static void gmpc_mpd_data_treeview_tooltip_finalize (GObject* obj) {
	GmpcMpdDataTreeviewTooltip * self;
	self = GMPC_MPD_DATA_TREEVIEW_TOOLTIP (obj);
	_g_object_unref0 (self->priv->par_widget);
	_g_object_unref0 (self->priv->image);
	_g_free0 (self->request_artist);
	_g_free0 (self->priv->checksum);
	G_OBJECT_CLASS (gmpc_mpd_data_treeview_tooltip_parent_class)->finalize (obj);
}


GType gmpc_mpd_data_treeview_tooltip_get_type (void) {
	static volatile gsize gmpc_mpd_data_treeview_tooltip_type_id__volatile = 0;
	if (g_once_init_enter (&gmpc_mpd_data_treeview_tooltip_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GmpcMpdDataTreeviewTooltipClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gmpc_mpd_data_treeview_tooltip_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GmpcMpdDataTreeviewTooltip), 0, (GInstanceInitFunc) gmpc_mpd_data_treeview_tooltip_instance_init, NULL };
		GType gmpc_mpd_data_treeview_tooltip_type_id;
		gmpc_mpd_data_treeview_tooltip_type_id = g_type_register_static (GTK_TYPE_WINDOW, "GmpcMpdDataTreeviewTooltip", &g_define_type_info, 0);
		g_once_init_leave (&gmpc_mpd_data_treeview_tooltip_type_id__volatile, gmpc_mpd_data_treeview_tooltip_type_id);
	}
	return gmpc_mpd_data_treeview_tooltip_type_id__volatile;
}



